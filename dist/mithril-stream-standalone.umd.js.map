{"version":3,"file":"mithril-stream-standalone.umd.js","sources":["../src/stream.js"],"sourcesContent":["/*\nMithril license: https://github.com/MithrilJS/mithril.js/blob/next/LICENSE\n*/\n\nfunction merge(streams) {\n  return combine(function () {\n    return streams.map(function (s) {\n      return s();\n    });\n  }, streams);\n}\n\nfunction scan(fn, acc, origin) {\n  var stream = origin.map(function (v) {\n    var next = fn(acc, v);\n    if (next !== Stream.SKIP) acc = next;\n    return next;\n  });\n  stream(acc);\n  return stream;\n}\n\nfunction scanMerge(tuples, seed) {\n  var streams = tuples.map(function (tuple) {\n    return tuple[0];\n  });\n\n  var stream = combine(function () {\n    var changed = arguments[arguments.length - 1];\n    streams.forEach(function (stream, i) {\n      if (changed.indexOf(stream) > -1) seed = tuples[i][1](seed, stream());\n    });\n\n    return seed;\n  }, streams);\n\n  stream(seed);\n\n  return stream;\n}\n\nfunction lift() {\n  var fn = arguments[0];\n  var streams = Array.prototype.slice.call(arguments, 1);\n  return merge(streams).map(function (streams) {\n    return fn.apply(undefined, streams);\n  });\n}\n\nfunction open(s) {\n  return (\n    s._state === \"pending\" || s._state === \"active\" || s._state === \"changing\"\n  );\n}\n\nvar Stream = function (value) {\n  var dependentStreams = [];\n  var dependentFns = [];\n\n  function stream(v) {\n    if (arguments.length && v !== Stream.SKIP) {\n      value = v;\n      if (open(stream)) {\n        stream._changing();\n        stream._state = \"active\";\n        // Cloning the list to ensure it's still iterated in intended\n        // order\n        dependentStreams.slice().forEach(function (s, i) {\n          if (open(s)) s(this[i](value));\n        }, dependentFns.slice());\n      }\n    }\n\n    return value;\n  }\n\n  stream.constructor = Stream;\n  stream._state =\n    arguments.length && value !== Stream.SKIP ? \"active\" : \"pending\";\n  stream._parents = [];\n\n  stream._changing = function () {\n    if (open(stream)) stream._state = \"changing\";\n    dependentStreams.forEach(function (s) {\n      s._changing();\n    });\n  };\n\n  stream._map = function (fn, ignoreInitial) {\n    var target = ignoreInitial ? Stream() : Stream(fn(value));\n    target._parents.push(stream);\n    dependentStreams.push(target);\n    dependentFns.push(fn);\n    return target;\n  };\n\n  stream.map = function (fn) {\n    return stream._map(fn, stream._state !== \"active\");\n  };\n\n  var end;\n  function createEnd() {\n    end = Stream();\n    end.map(function (value) {\n      if (value === true) {\n        stream._parents.forEach(function (p) {\n          p._unregisterChild(stream);\n        });\n        stream._state = \"ended\";\n        stream._parents.length =\n          dependentStreams.length =\n          dependentFns.length =\n            0;\n      }\n      return value;\n    });\n    return end;\n  }\n\n  stream.toJSON = function () {\n    return value != null && typeof value.toJSON === \"function\"\n      ? value.toJSON()\n      : value;\n  };\n\n  stream[\"fantasy-land/map\"] = stream.map;\n  stream[\"fantasy-land/ap\"] = function (x) {\n    return combine(\n      function (s1, s2) {\n        return s1()(s2());\n      },\n      [x, stream]\n    );\n  };\n\n  stream._unregisterChild = function (child) {\n    var childIndex = dependentStreams.indexOf(child);\n    if (childIndex !== -1) {\n      dependentStreams.splice(childIndex, 1);\n      dependentFns.splice(childIndex, 1);\n    }\n  };\n\n  Object.defineProperty(stream, \"end\", {\n    get: function () {\n      return end || createEnd();\n    },\n  });\n\n  return stream;\n};\n\nfunction combine(fn, streams) {\n  var ready = streams.every(function (s) {\n    if (s.constructor !== Stream)\n      throw new Error(\n        \"Ensure that each item passed to stream.combine/stream.merge/lift is a stream.\"\n      );\n    return s._state === \"active\";\n  });\n  var stream = ready\n    ? Stream(fn.apply(null, streams.concat([streams])))\n    : Stream();\n\n  var changed = [];\n\n  var mappers = streams.map(function (s) {\n    return s._map(function (value) {\n      changed.push(s);\n      if (\n        ready ||\n        streams.every(function (s) {\n          return s._state !== \"pending\";\n        })\n      ) {\n        ready = true;\n        stream(fn.apply(null, streams.concat([changed])));\n        changed = [];\n      }\n      return value;\n    }, true);\n  });\n\n  var endStream = stream.end.map(function (value) {\n    if (value === true) {\n      mappers.forEach(function (mapper) {\n        mapper.end(true);\n      });\n      endStream.end(true);\n    }\n    return undefined;\n  });\n\n  return stream;\n}\n\nStream.SKIP = {};\nStream.lift = lift;\nStream.scan = scan;\nStream.merge = merge;\nStream.combine = combine;\nStream.scanMerge = scanMerge;\nStream[\"fantasy-land/of\"] = Stream;\n\nvar warnedHalt = false;\nObject.defineProperty(Stream, \"HALT\", {\n  get: function () {\n    warnedHalt ||\n      console.log(\"HALT is deprecated and has been renamed to SKIP\");\n    warnedHalt = true;\n    return Stream.SKIP;\n  },\n});\n\nexport { Stream as default };\n"],"names":["streams","combine","map","s","_state","Stream","value","end","dependentStreams","dependentFns","v","arguments","length","SKIP","open","stream","_changing","slice","forEach","i","this","value2","_parents","p","_unregisterChild","constructor","_map","fn","ignoreInitial","target","push","toJSON","x","s1","s2","child","childIndex","indexOf","splice","defineProperty","get","createEnd","ready","every","Error","apply","concat","changed","mappers","endStream","mapper","lift","Array","prototype","call","merge","streams2","scan","acc","origin","next","scanMerge","tuples","seed","tuple","stream2","warnedHalt","console","log"],"mappings":"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"}